import sys
from typing import Callable
import matplotlib.pyplot as plt
import numpy as np
import inspect

def harmonic_oscillator(x: float, k: float = 1, m: float = 1) -> float:
    return -(k/m)*x

def sinx(x: float) -> float:
    return np.sin(x)

def pendulum(x: float, g: float = 9.8, l: float = 1) -> float:
    return -(g/l)*np.sin(x)

def f(t: float, y: float) -> float:
    return t**3 * np.sqrt(4 - y**2)

class EdoSolver:
    def __init__(self, x0: float, v0: float | None = None, t: float = 10):
        self.x0 = x0
        self.v0 = v0
        self.delta = min(0.001, t/1000)
        self.t = t

    def solve(self, function: Callable):
        """
        Function designed to switch between first and second order ode 
        based on the number of parameters that the function has.
        """
        sig = inspect.signature(function)
        params = len(sig.parameters)

        if params == 1:
            return self._solve_second_order(f)
        elif params == 2:
            return self._solve_first_order(f)
        else:
            raise ValueError(f"{params} parameters given: not implemented")
        
    def explicit_euler(self, f: Callable) -> list[float]:
        """
        [UNUSED]
        Simplest Euler method to solve ode. It's highly unstable for long 
        simulation time.
        It's currently unused: implemented only for learning purpose.
        """
        t0 = 0 # time interval for the simulation
        x, v = self.x0, self.v0
        pos = [x]

        while t0 < self.t:
            a = f(x)
            x += v * self.delta
            v += a * self.delta
            pos.append(x)
            t0 += self.delta

        return pos

    def _solve_second_order(self, f: Callable) -> tuple[list[float], list[float]]:
        """
        Semi-Implicit Euler method. Called only when the input function 
        accepts a single parameter. More stable than the explicit Euler 
        method and simple enough to implement.
        """
        t0, x, v = 0.0, self.x0, self.v0
        times, pos = [t0], [x]

        while t0 < self.t:
            v += f(x) * self.delta
            x += v * self.delta
            t0 += self.delta
            times.append(t0)
            pos.append(x)

        return times, pos
    
    def _solve_first_order(self, f: Callable):
        t, y = 0.0 , self.x0
        times, sol = [t], [y]
        while t < self.t:
            y += f(t, y) * self.delta
            t += self.delta
            times.append(t)
            sol.append(y)

        return times, sol
    
try:
    t = int(sys.argv[1])
    edo = EdoSolver(-0.5, 0.2, t)
except ValueError:
    edo = EdoSolver(-0.5, 0.2)
except IndexError:
    edo = EdoSolver(-0.5, 0.2)
gen = edo._solve_first_order(f)
harm = edo._solve_second_order(harmonic_oscillator)
plt.plot(harm[0], harm[1], color="blue", label= "Semi-Implicit euler Method")
plt.plot(gen[0], gen[1], color="red", label="Semi-Implicit Euler Method") 
plt.xlabel("Time (s)")
plt.ylabel("Position (m)")
plt.grid()
plt.legend()
plt.show()
